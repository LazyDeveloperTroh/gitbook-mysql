# 풀 테이블 스캔과 풀 인덱스 스캔

### 풀 테이블 스캔과 풀 인덱스 스캔

<mark style="background-color:blue;">풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다. MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.</mark>

* 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
* WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
* 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스 B-Tree 샘플링해서 조사한 통계 정보 기준)

일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다. 그래서 풀 테이블을 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다. \
\
<mark style="background-color:blue;">InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다. 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.</mark> \
\
즉 풀 테이블 스캔이 시작되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드에가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 포그라운드 스레드는 백그라운드 스레드가 버퍼풀에 적재된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 빠르게 처리되는 것이다.\
\
리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다. &#x20;

```sql
SELECT COUNT(*) FROM employees;
```

이 쿼리는 아무런 조건 없이 employees 테이블의 레코드 건수를 조회하고 있으므로 당연히 풀 테이블 스캔을 할 것처럼 보인다. 하지만 실제 실행 계획은 풀 테이블 스캔보다는 풀 인덱스 스캔을 하게 될 가능성이 높다. 단순히 레코드의 건수만 필요로 하는 쿼리이기 때문에 용량이 작은 인덱스를 선택하는 것이 효율적이기 때문이다.\
\
하지만 다음과 같이 레코드에만 있는 칼럼이 필요한 쿼리의 경우에는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 이용한다.

```sql
SELECT * FROM employees;
```

